'''
Author: Ben Ross
Date: 29/12/21
Outline:
A file holding function for compressing and decompressing data using a standard
huffman tree. Building and storing custom trees is undesirable for this application
as most messages will be short and storing the tree will actually cause the compressed
text to be larger than the uncompressed text.'''

# Python Imports
from collections import Counter

# Global Variables
STANDARD_TREE: dict[int, str] = {32: '010', 101: '0001', 116: '0110', 97: '1001', 111: '1011', 105: '1100', 110: '1101', 114: '1111', 115: '00000', 104: '01110', 108: '10000', 100: '11100', 99: '000010', 117: '001000', 109: '001010', 93: '001101', 91: '001110', 112: '011111', 103: '100011', 102: '101000', 10: '101011', 121: '111011', 119: '0000111', 98: '0010011', 44: '0011000', 39: '0011001', 46: '0011111', 118: '1010010', 59: '00100100', 107: '00111100', 38: '01111000', 124: '01111011', 49: '10001001', 47: '10001010', 61: '10100110', 65: '10101000', 48: '10101001', 67: '10101011', 84: '11101000', 45: '11101001', 58: '11101011', 73: '000011000', 83: '000011001', 63: '001011001', 113: '001011010', 50: '001011011', 60: '001011100', 62: '001011101', 57: '001011111', 120: '001111011', 42: '011110010', 66: '011110011', 41: '011110100', 40: '011110101', 69: '100010001', 77: '100010110', 80: '100010111', 68: '101001111', 72: '101010100', 82: '111010101', 70: '0000110100', 71: '0000110101', 53: '0000110110', 51: '0000110111', 78: '0010010101', 56: '0010010110', 52: '0010010111', 76: '0010110000', 54: '0010110001', 87: '0010111101', 55: '0011110100', 79: '0011110101', 122: '1000100001', 106: '1010011101', 125: '1010101011', 123: '1110101000', 85: '1110101001', 74: '00100101000', 75: '00101111001', 34: '10001000000', 95: '10100111000', 86: '10100111001', 35: '10101010100', 33: '001001010011', 89: '001011110001', 90: '100010000011', 92: '0010010100100', 37: '0010111100000', 81: '1000100000101', 88: '1010101010100', 233: '1010101010110', 43: '00100101001010', 225: '10101010101011', 9: '001001010010111', 237: '001011110000101', 36: '001011110000110', 94: '100010000010000', 243: '100010000010010', 246: '101010101010100', 126: '101010101011110', 252: '101010101011111', 228: '0010010100101100', 232: '1000100000100010', 176: '1000100000100110', 250: '00100101001011011', 178: '00101111000010000', 241: '00101111000010001', 231: '00101111000010010', 201: '00101111000010011', 230: '00101111000011101', 240: '00101111000011110', 224: '10001000001000110', 248: '10001000001001110', 234: '10001000001001111', 235: '10101010101010110', 183: '10101010101110010', 244: '10101010101110011', 227: '10101010101110101', 215: '10101010101110110', 229: '001011110000111000', 226: '001011110000111110', 193: '100010000010001110', 163: '101010101010101000', 160: '101010101010101001', 96: '101010101010101110', 239: '101010101011100000', 238: '101010101011100001', 253: '101010101011101000', 64: '101010101011101110', 223: '0010010100101101001', 242: '0010010100101101011', 254: '0010111100001110011', 245: '1000100000100011110', 179: '1010101010101010100', 198: '1010101010101010101', 236: '1010101010101011110', 189: '1010101010101011111', 214: '1010101010111000100', 197: '1010101010111000101', 175: '1010101010111000111', 251: '1010101010111010010', 249: '1010101010111011110', 199: '00100101001011010000', 216: '00100101001011010001', 206: '00100101001011010100', 196: '00100101001011010101', 167: '00101111000011100100', 177: '00101111000011100101', 211: '00101111000011111110', 220: '10001000001000111110', 174: '10001000001000111111', 205: '10101010101010101101', 180: '10101010101010101110', 222: '10101010101110001100', 181: '10101010101110100111', 188: '10101010101110111111', 187: '001011110000111111011', 171: '001011110000111111110', 218: '101010101010101011000', 185: '101010101010101011110', 172: '101010101011100011010', 192: '101010101011101001100', 208: '0010111100001111110000', 200: '0010111100001111110010', 247: '0010111100001111110011', 194: '0010111100001111110100', 169: '0010111100001111110101', 255: '1010101010101010111110', 161: '1010101010101010111111', 191: '1010101010111000110111', 173: '1010101010111010011010', 186: '1010101010111011111000', 195: '1010101010111011111010', 162: '1010101010111011111011', 204: '00101111000011111100010', 202: '00101111000011111111100', 209: '00101111000011111111110', 203: '00101111000011111111111', 190: '10101010101010101100100', 182: '10101010101110001101100', 165: '10101010101110001101101', 213: '10101010101110100110111', 210: '10101010101110111110010', 221: '10101010101110111110011', 217: '001011110000111111000110', 207: '001011110000111111111010', 168: '001011110000111111111011', 170: '101010101010101011001010', 164: '101010101010101011001011', 219: '101010101010101011001100', 212: '101010101010101011001101', 184: '1010101010101010110011100', 166: '1010101010101010110011101', 151: '00101111000011111100011101', 148: '001011110000111111000111100', 146: '001011110000111111000111101', 157: '0010111100001111110001111100', 156: '0010111100001111110001111101', 159: '0010111100001111110001111110', 158: '0010111100001111110001111111', 134: '1010101010101010110011110000', 133: '1010101010101010110011110001', 136: '1010101010101010110011110010', 135: '1010101010101010110011110011', 130: '1010101010101010110011110100', 129: '1010101010101010110011110101', 132: '1010101010101010110011110110', 131: '1010101010101010110011110111', 142: '1010101010101010110011111000', 141: '1010101010101010110011111001', 144: '1010101010101010110011111010', 143: '1010101010101010110011111011', 138: '1010101010101010110011111100', 137: '1010101010101010110011111101', 140: '1010101010101010110011111110', 139: '1010101010101010110011111111', 23: '1010101010111010011011000000', 22: '1010101010111010011011000001', 25: '1010101010111010011011000010', 24: '1010101010111010011011000011', 19: '1010101010111010011011000100', 18: '1010101010111010011011000101', 21: '1010101010111010011011000110', 20: '1010101010111010011011000111', 31: '1010101010111010011011001000', 30: '1010101010111010011011001001', 128: '1010101010111010011011001010', 127: '1010101010111010011011001011', 27: '1010101010111010011011001100', 26: '1010101010111010011011001101', 29: '1010101010111010011011001110', 28: '1010101010111010011011001111', 5: '1010101010111010011011010000', 4: '1010101010111010011011010001', 7: '1010101010111010011011010010', 6: '1010101010111010011011010011', 1: '1010101010111010011011010100', 0: '1010101010111010011011010101', 3: '1010101010111010011011010110', 2: '1010101010111010011011010111', 15: '1010101010111010011011011000', 14: '1010101010111010011011011001', 17: '1010101010111010011011011010', 16: '1010101010111010011011011011', 11: '1010101010111010011011011100', 8: '1010101010111010011011011101', 13: '1010101010111010011011011110', 12: '1010101010111010011011011111', 153: '00101111000011111100011100000', 152: '00101111000011111100011100001', 155: '00101111000011111100011100010', 154: '00101111000011111100011100011', 147: '00101111000011111100011100100', 145: '00101111000011111100011100101', 150: '00101111000011111100011100110', 149: '00101111000011111100011100111'}
INVERSE_STANDARD_TREE: dict[str, int] = {'010': 32, '0001': 101, '0110': 116, '1001': 97, '1011': 111, '1100': 105, '1101': 110, '1111': 114, '00000': 115, '01110': 104, '10000': 108, '11100': 100, '000010': 99, '001000': 117, '001010': 109, '001101': 93, '001110': 91, '011111': 112, '100011': 103, '101000': 102, '101011': 10, '111011': 121, '0000111': 119, '0010011': 98, '0011000': 44, '0011001': 39, '0011111': 46, '1010010': 118, '00100100': 59, '00111100': 107, '01111000': 38, '01111011': 124, '10001001': 49, '10001010': 47, '10100110': 61, '10101000': 65, '10101001': 48, '10101011': 67, '11101000': 84, '11101001': 45, '11101011': 58, '000011000': 73, '000011001': 83, '001011001': 63, '001011010': 113, '001011011': 50, '001011100': 60, '001011101': 62, '001011111': 57, '001111011': 120, '011110010': 42, '011110011': 66, '011110100': 41, '011110101': 40, '100010001': 69, '100010110': 77, '100010111': 80, '101001111': 68, '101010100': 72, '111010101': 82, '0000110100': 70, '0000110101': 71, '0000110110': 53, '0000110111': 51, '0010010101': 78, '0010010110': 56, '0010010111': 52, '0010110000': 76, '0010110001': 54, '0010111101': 87, '0011110100': 55, '0011110101': 79, '1000100001': 122, '1010011101': 106, '1010101011': 125, '1110101000': 123, '1110101001': 85, '00100101000': 74, '00101111001': 75, '10001000000': 34, '10100111000': 95, '10100111001': 86, '10101010100': 35, '001001010011': 33, '001011110001': 89, '100010000011': 90, '0010010100100': 92, '0010111100000': 37, '1000100000101': 81, '1010101010100': 88, '1010101010110': 233, '00100101001010': 43, '10101010101011': 225, '001001010010111': 9, '001011110000101': 237, '001011110000110': 36, '100010000010000': 94, '100010000010010': 243, '101010101010100': 246, '101010101011110': 126, '101010101011111': 252, '0010010100101100': 228, '1000100000100010': 232, '1000100000100110': 176, '00100101001011011': 250, '00101111000010000': 178, '00101111000010001': 241, '00101111000010010': 231, '00101111000010011': 201, '00101111000011101': 230, '00101111000011110': 240, '10001000001000110': 224, '10001000001001110': 248, '10001000001001111': 234, '10101010101010110': 235, '10101010101110010': 183, '10101010101110011': 244, '10101010101110101': 227, '10101010101110110': 215, '001011110000111000': 229, '001011110000111110': 226, '100010000010001110': 193, '101010101010101000': 163, '101010101010101001': 160, '101010101010101110': 96, '101010101011100000': 239, '101010101011100001': 238, '101010101011101000': 253, '101010101011101110': 64, '0010010100101101001': 223, '0010010100101101011': 242, '0010111100001110011': 254, '1000100000100011110': 245, '1010101010101010100': 179, '1010101010101010101': 198, '1010101010101011110': 236, '1010101010101011111': 189, '1010101010111000100': 214, '1010101010111000101': 197, '1010101010111000111': 175, '1010101010111010010': 251, '1010101010111011110': 249, '00100101001011010000': 199, '00100101001011010001': 216, '00100101001011010100': 206, '00100101001011010101': 196, '00101111000011100100': 167, '00101111000011100101': 177, '00101111000011111110': 211, '10001000001000111110': 220, '10001000001000111111': 174, '10101010101010101101': 205, '10101010101010101110': 180, '10101010101110001100': 222, '10101010101110100111': 181, '10101010101110111111': 188, '001011110000111111011': 187, '001011110000111111110': 171, '101010101010101011000': 218, '101010101010101011110': 185, '101010101011100011010': 172, '101010101011101001100': 192, '0010111100001111110000': 208, '0010111100001111110010': 200, '0010111100001111110011': 247, '0010111100001111110100': 194, '0010111100001111110101': 169, '1010101010101010111110': 255, '1010101010101010111111': 161, '1010101010111000110111': 191, '1010101010111010011010': 173, '1010101010111011111000': 186, '1010101010111011111010': 195, '1010101010111011111011': 162, '00101111000011111100010': 204, '00101111000011111111100': 202, '00101111000011111111110': 209, '00101111000011111111111': 203, '10101010101010101100100': 190, '10101010101110001101100': 182, '10101010101110001101101': 165, '10101010101110100110111': 213, '10101010101110111110010': 210, '10101010101110111110011': 221, '001011110000111111000110': 217, '001011110000111111111010': 207, '001011110000111111111011': 168, '101010101010101011001010': 170, '101010101010101011001011': 164, '101010101010101011001100': 219, '101010101010101011001101': 212, '1010101010101010110011100': 184, '1010101010101010110011101': 166, '00101111000011111100011101': 151, '001011110000111111000111100': 148, '001011110000111111000111101': 146, '0010111100001111110001111100': 157, '0010111100001111110001111101': 156, '0010111100001111110001111110': 159, '0010111100001111110001111111': 158, '1010101010101010110011110000': 134, '1010101010101010110011110001': 133, '1010101010101010110011110010': 136, '1010101010101010110011110011': 135, '1010101010101010110011110100': 130, '1010101010101010110011110101': 129, '1010101010101010110011110110': 132, '1010101010101010110011110111': 131, '1010101010101010110011111000': 142, '1010101010101010110011111001': 141, '1010101010101010110011111010': 144, '1010101010101010110011111011': 143, '1010101010101010110011111100': 138, '1010101010101010110011111101': 137, '1010101010101010110011111110': 140, '1010101010101010110011111111': 139, '1010101010111010011011000000': 23, '1010101010111010011011000001': 22, '1010101010111010011011000010': 25, '1010101010111010011011000011': 24, '1010101010111010011011000100': 19, '1010101010111010011011000101': 18, '1010101010111010011011000110': 21, '1010101010111010011011000111': 20, '1010101010111010011011001000': 31, '1010101010111010011011001001': 30, '1010101010111010011011001010': 128, '1010101010111010011011001011': 127, '1010101010111010011011001100': 27, '1010101010111010011011001101': 26, '1010101010111010011011001110': 29, '1010101010111010011011001111': 28, '1010101010111010011011010000': 5, '1010101010111010011011010001': 4, '1010101010111010011011010010': 7, '1010101010111010011011010011': 6, '1010101010111010011011010100': 1, '1010101010111010011011010101': 0, '1010101010111010011011010110': 3, '1010101010111010011011010111': 2, '1010101010111010011011011000': 15, '1010101010111010011011011001': 14, '1010101010111010011011011010': 17, '1010101010111010011011011011': 16, '1010101010111010011011011100': 11, '1010101010111010011011011101': 8, '1010101010111010011011011110': 13, '1010101010111010011011011111': 12, '00101111000011111100011100000': 153, '00101111000011111100011100001': 152, '00101111000011111100011100010': 155, '00101111000011111100011100011': 154, '00101111000011111100011100100': 147, '00101111000011111100011100101': 145, '00101111000011111100011100110': 150, '00101111000011111100011100111': 149}
INT_TO_BIN: dict[int, str] = {0: '00000000', 1: '00000001', 2: '00000010', 3: '00000011', 4: '00000100', 5: '00000101', 6: '00000110', 7: '00000111', 8: '00001000', 9: '00001001', 10: '00001010', 11: '00001011', 12: '00001100', 13: '00001101', 14: '00001110', 15: '00001111', 16: '00010000', 17: '00010001', 18: '00010010', 19: '00010011', 20: '00010100', 21: '00010101', 22: '00010110', 23: '00010111', 24: '00011000', 25: '00011001', 26: '00011010', 27: '00011011', 28: '00011100', 29: '00011101', 30: '00011110', 31: '00011111', 32: '00100000', 33: '00100001', 34: '00100010', 35: '00100011', 36: '00100100', 37: '00100101', 38: '00100110', 39: '00100111', 40: '00101000', 41: '00101001', 42: '00101010', 43: '00101011', 44: '00101100', 45: '00101101', 46: '00101110', 47: '00101111', 48: '00110000', 49: '00110001', 50: '00110010', 51: '00110011', 52: '00110100', 53: '00110101', 54: '00110110', 55: '00110111', 56: '00111000', 57: '00111001', 58: '00111010', 59: '00111011', 60: '00111100', 61: '00111101', 62: '00111110', 63: '00111111', 64: '01000000', 65: '01000001', 66: '01000010', 67: '01000011', 68: '01000100', 69: '01000101', 70: '01000110', 71: '01000111', 72: '01001000', 73: '01001001', 74: '01001010', 75: '01001011', 76: '01001100', 77: '01001101', 78: '01001110', 79: '01001111', 80: '01010000', 81: '01010001', 82: '01010010', 83: '01010011', 84: '01010100', 85: '01010101', 86: '01010110', 87: '01010111', 88: '01011000', 89: '01011001', 90: '01011010', 91: '01011011', 92: '01011100', 93: '01011101', 94: '01011110', 95: '01011111', 96: '01100000', 97: '01100001', 98: '01100010', 99: '01100011', 100: '01100100', 101: '01100101', 102: '01100110', 103: '01100111', 104: '01101000', 105: '01101001', 106: '01101010', 107: '01101011', 108: '01101100', 109: '01101101', 110: '01101110', 111: '01101111', 112: '01110000', 113: '01110001', 114: '01110010', 115: '01110011', 116: '01110100', 117: '01110101', 118: '01110110', 119: '01110111', 120: '01111000', 121: '01111001', 122: '01111010', 123: '01111011', 124: '01111100', 125: '01111101', 126: '01111110', 127: '01111111', 128: '10000000', 129: '10000001', 130: '10000010', 131: '10000011', 132: '10000100', 133: '10000101', 134: '10000110', 135: '10000111', 136: '10001000', 137: '10001001', 138: '10001010', 139: '10001011', 140: '10001100', 141: '10001101', 142: '10001110', 143: '10001111', 144: '10010000', 145: '10010001', 146: '10010010', 147: '10010011', 148: '10010100', 149: '10010101', 150: '10010110', 151: '10010111', 152: '10011000', 153: '10011001', 154: '10011010', 155: '10011011', 156: '10011100', 157: '10011101', 158: '10011110', 159: '10011111', 160: '10100000', 161: '10100001', 162: '10100010', 163: '10100011', 164: '10100100', 165: '10100101', 166: '10100110', 167: '10100111', 168: '10101000', 169: '10101001', 170: '10101010', 171: '10101011', 172: '10101100', 173: '10101101', 174: '10101110', 175: '10101111', 176: '10110000', 177: '10110001', 178: '10110010', 179: '10110011', 180: '10110100', 181: '10110101', 182: '10110110', 183: '10110111', 184: '10111000', 185: '10111001', 186: '10111010', 187: '10111011', 188: '10111100', 189: '10111101', 190: '10111110', 191: '10111111', 192: '11000000', 193: '11000001', 194: '11000010', 195: '11000011', 196: '11000100', 197: '11000101', 198: '11000110', 199: '11000111', 200: '11001000', 201: '11001001', 202: '11001010', 203: '11001011', 204: '11001100', 205: '11001101', 206: '11001110', 207: '11001111', 208: '11010000', 209: '11010001', 210: '11010010', 211: '11010011', 212: '11010100', 213: '11010101', 214: '11010110', 215: '11010111', 216: '11011000', 217: '11011001', 218: '11011010', 219: '11011011', 220: '11011100', 221: '11011101', 222: '11011110', 223: '11011111', 224: '11100000', 225: '11100001', 226: '11100010', 227: '11100011', 228: '11100100', 229: '11100101', 230: '11100110', 231: '11100111', 232: '11101000', 233: '11101001', 234: '11101010', 235: '11101011', 236: '11101100', 237: '11101101', 238: '11101110', 239: '11101111', 240: '11110000', 241: '11110001', 242: '11110010', 243: '11110011', 244: '11110100', 245: '11110101', 246: '11110110', 247: '11110111', 248: '11111000', 249: '11111001', 250: '11111010', 251: '11111011', 252: '11111100', 253: '11111101', 254: '11111110', 255: '11111111'}
BIN_TO_INT: dict[str, int] = {'00000000': 0, '00000001': 1, '00000010': 2, '00000011': 3, '00000100': 4, '00000101': 5, '00000110': 6, '00000111': 7, '00001000': 8, '00001001': 9, '00001010': 10, '00001011': 11, '00001100': 12, '00001101': 13, '00001110': 14, '00001111': 15, '00010000': 16, '00010001': 17, '00010010': 18, '00010011': 19, '00010100': 20, '00010101': 21, '00010110': 22, '00010111': 23, '00011000': 24, '00011001': 25, '00011010': 26, '00011011': 27, '00011100': 28, '00011101': 29, '00011110': 30, '00011111': 31, '00100000': 32, '00100001': 33, '00100010': 34, '00100011': 35, '00100100': 36, '00100101': 37, '00100110': 38, '00100111': 39, '00101000': 40, '00101001': 41, '00101010': 42, '00101011': 43, '00101100': 44, '00101101': 45, '00101110': 46, '00101111': 47, '00110000': 48, '00110001': 49, '00110010': 50, '00110011': 51, '00110100': 52, '00110101': 53, '00110110': 54, '00110111': 55, '00111000': 56, '00111001': 57, '00111010': 58, '00111011': 59, '00111100': 60, '00111101': 61, '00111110': 62, '00111111': 63, '01000000': 64, '01000001': 65, '01000010': 66, '01000011': 67, '01000100': 68, '01000101': 69, '01000110': 70, '01000111': 71, '01001000': 72, '01001001': 73, '01001010': 74, '01001011': 75, '01001100': 76, '01001101': 77, '01001110': 78, '01001111': 79, '01010000': 80, '01010001': 81, '01010010': 82, '01010011': 83, '01010100': 84, '01010101': 85, '01010110': 86, '01010111': 87, '01011000': 88, '01011001': 89, '01011010': 90, '01011011': 91, '01011100': 92, '01011101': 93, '01011110': 94, '01011111': 95, '01100000': 96, '01100001': 97, '01100010': 98, '01100011': 99, '01100100': 100, '01100101': 101, '01100110': 102, '01100111': 103, '01101000': 104, '01101001': 105, '01101010': 106, '01101011': 107, '01101100': 108, '01101101': 109, '01101110': 110, '01101111': 111, '01110000': 112, '01110001': 113, '01110010': 114, '01110011': 115, '01110100': 116, '01110101': 117, '01110110': 118, '01110111': 119, '01111000': 120, '01111001': 121, '01111010': 122, '01111011': 123, '01111100': 124, '01111101': 125, '01111110': 126, '01111111': 127, '10000000': 128, '10000001': 129, '10000010': 130, '10000011': 131, '10000100': 132, '10000101': 133, '10000110': 134, '10000111': 135, '10001000': 136, '10001001': 137, '10001010': 138, '10001011': 139, '10001100': 140, '10001101': 141, '10001110': 142, '10001111': 143, '10010000': 144, '10010001': 145, '10010010': 146, '10010011': 147, '10010100': 148, '10010101': 149, '10010110': 150, '10010111': 151, '10011000': 152, '10011001': 153, '10011010': 154, '10011011': 155, '10011100': 156, '10011101': 157, '10011110': 158, '10011111': 159, '10100000': 160, '10100001': 161, '10100010': 162, '10100011': 163, '10100100': 164, '10100101': 165, '10100110': 166, '10100111': 167, '10101000': 168, '10101001': 169, '10101010': 170, '10101011': 171, '10101100': 172, '10101101': 173, '10101110': 174, '10101111': 175, '10110000': 176, '10110001': 177, '10110010': 178, '10110011': 179, '10110100': 180, '10110101': 181, '10110110': 182, '10110111': 183, '10111000': 184, '10111001': 185, '10111010': 186, '10111011': 187, '10111100': 188, '10111101': 189, '10111110': 190, '10111111': 191, '11000000': 192, '11000001': 193, '11000010': 194, '11000011': 195, '11000100': 196, '11000101': 197, '11000110': 198, '11000111': 199, '11001000': 200, '11001001': 201, '11001010': 202, '11001011': 203, '11001100': 204, '11001101': 205, '11001110': 206, '11001111': 207, '11010000': 208, '11010001': 209, '11010010': 210, '11010011': 211, '11010100': 212, '11010101': 213, '11010110': 214, '11010111': 215, '11011000': 216, '11011001': 217, '11011010': 218, '11011011': 219, '11011100': 220, '11011101': 221, '11011110': 222, '11011111': 223, '11100000': 224, '11100001': 225, '11100010': 226, '11100011': 227, '11100100': 228, '11100101': 229, '11100110': 230, '11100111': 231, '11101000': 232, '11101001': 233, '11101010': 234, '11101011': 235, '11101100': 236, '11101101': 237, '11101110': 238, '11101111': 239, '11110000': 240, '11110001': 241, '11110010': 242, '11110011': 243, '11110100': 244, '11110101': 245, '11110110': 246, '11110111': 247, '11111000': 248, '11111001': 249, '11111010': 250, '11111011': 251, '11111100': 252, '11111101': 253, '11111110': 254, '11111111': 255}

class Node():
    '''The Node Class'''
    def __init__(self, frequency: int, character: int | None = None):
        self.character: int | None= character
        self.frequency: int = frequency
        self.huffman_code: str = ''
        self.left: Node | None = None
        self.right: Node | None = None

    def __repr__(self):
        char_rep: str = 'None' if self.character is None else chr(self.character)
        return f'{char_rep}, {self.frequency}, {self.huffman_code}'

    def __lt__(self, other):
        return self.frequency < other.frequency


#####################################################################################
# SHARED FUNCTIONS 
def findHuffmanCodes(root: Node | None) -> tuple[dict[int, str], str]:
    '''Finds the huffman codes for each character'''
    dict_tree: dict[int, str] = {}

    def preorderTraversal(root: Node | None, current_code: str, str_tree) -> str:
        if root is not None:
            if root.character is not None: # the root is a leaf node
                root.huffman_code = current_code
                dict_tree[root.character] = root.huffman_code
                str_tree += '1' + INT_TO_BIN[root.character]
            else:
                str_tree += '0'
                str_tree = preorderTraversal(root.left, current_code+'0', str_tree)
                str_tree = preorderTraversal(root.right, current_code+'1', str_tree)
        return str_tree

    str_tree: str = preorderTraversal(root, '', '')
    return dict_tree, str_tree

#####################################################################################
# COMPRESSOR FUNCTIONS
def createHuffmanTree(data: bytes) -> Node:
    '''Analyses the frequency of the data, then builds a huffman tree.'''
    frequency_list: list[Node] = [Node(freq, char) for char, freq in Counter(data).items()]
    frequency_list.sort(key=lambda x: x.character if x.character is not None else 0, reverse=True) # sort alphabetically
    frequency_list.sort(key=lambda x: x.frequency, reverse=True) # sort by frequency

    # Main loop for building the tree
    while len(frequency_list) > 1: # while there are still two trees to combine
        node1: Node = frequency_list[-2]
        node2: Node = frequency_list[-1]
        frequency_sum: int = node1.frequency + node2.frequency
        subtree_root: Node = Node(frequency_sum)

        subtree_root.left = node1
        subtree_root.right = node2

        frequency_list = frequency_list[:-2] # remove the last two characters
        frequency_list.append(subtree_root)
        frequency_list.sort(key=lambda x: x.frequency, reverse=True) # sort by frequency

        # print(len(frequency_list), frequency_list)
        # sleep(1)

    return frequency_list[0] # return the root of the tree

def compressWithCustomTree(data: bytes) -> bytes:
    '''Builds a custom tree according to the byte freqencies of the data
    and encode the tree into the message'''
    root: Node = createHuffmanTree(data)
    tree: dict[int, str]
    str_tree: str
    tree, str_tree = findHuffmanCodes(root)

    # Use the tree dict to replace the bytes with the proper encoding and join
    compressed_data_list: list[str] = [tree[byte] for byte in data]
    compressed_data: str = ''.join(compressed_data_list)

    # Calculate binary tree representation and add to 
    tree_size: str = format(len(str_tree), 'b').zfill(16)
    padding_size: int = 8 - ((1 + 16 + len(str_tree) + len(compressed_data)) % 8) # custom tree flag + tree_size + tree + comp_data
    padding_size_bin: str = INT_TO_BIN[padding_size]
    padding: str = '0' * padding_size

    # Combine the padding length, custom tree flag, tree size and tree, compressed data, and padding
    full_binary: str = padding_size_bin + '1' + tree_size + str_tree + compressed_data + padding
    length: int = len(full_binary)

    # Chop up the resulting string into 8 bit strings, convert to bytes, then return
    full_bin_list: list[str] = [full_binary[i:i+8] for i in range(0, length, 8)]
    return bytes(BIN_TO_INT[byte] for byte in full_bin_list)

def compressWithStandardTree(data: bytes) -> bytes:
    '''Takes some data as bytes, compresses and returns it using huffman encoding
    from a standard tree.'''
    # Use the TREE dict to replace the bytes with the proper encoding and join
    compressed_data_list: list[str] = [STANDARD_TREE[byte] for byte in data]
    compressed_data: str = ''.join(compressed_data_list)

    # Calculate the eof variables
    padding_size: int = 8 - (1 + len(compressed_data) % 8) # include custom tree flag
    padding_size_bin: str = INT_TO_BIN[padding_size]
    padding: str = '0' * padding_size

    # Combine the padding length, compressed data, and padding
    full_binary: str = padding_size_bin + '0' + compressed_data + padding
    length: int = len(full_binary)
    
    # Chop up the resulting string into 8 bit strings, convert to bytes, then return
    full_bin_list: list[str] = [full_binary[i:i+8] for i in range(0, length, 8)]
    return bytes(BIN_TO_INT[byte] for byte in full_bin_list)

def compress(data: bytes, build_own_tree: bool = False) -> bytes:
    '''Compresses some data using huffman encoding. Includes flag for whether or not
    to use a custom huffman tree based on the freuqencies of this data, or to use a
    standard huffman tree.'''
    if build_own_tree:
        return compressWithCustomTree(data)
    else:
        return compressWithStandardTree(data)



#####################################################################################
# DECOMPRESSOR FUNCTIONS
def rebuildHuffmanTree(full_binary: str) -> tuple[Node, str]:
    '''Seperates the padding and tree from the binary data and rebuilds the huffman
    tree from the encoded version.'''
    # Seperate the eof and tree from the text
    padding_size: int = int(full_binary[:8], 2) # extract the first byte 
    tree_size: int = int(full_binary[9:25], 2) # skip custom tree flag, extract next two bytes
    str_tree: str = full_binary[25:25+tree_size] # extract the str repped tree
    compressed_data: str = full_binary[25+tree_size:-padding_size] # extract the rest of the data

    # Rebuild huffman tree from it's string representation
    root: Node = Node(0)
    stack: list[Node] = [root]
    idx: int = 0

    while idx < len(str_tree):
        bit = str_tree[idx]

        current_node: Node = stack.pop()
        while current_node.right is not None: # if the node has a right child, we are done with it
            current_node = stack.pop()
        
        # print(current_node)
        if bit == '0': # not a character
            current_node.left = Node(0)  # create left child
            current_node.right = Node(0) # create right child
            stack.append(current_node)       # push the current node and it's chidlren onto the stack
            stack.append(current_node.right) #
            stack.append(current_node.left)  #

        else: # a character
            character = str_tree[idx+1:idx+9] # get character byte
            current_node.character = BIN_TO_INT[character] # set the character
            idx += 8
        idx += 1

    return root, compressed_data

def decompress(data: bytes) -> bytes:
    '''Takes some data compressed using huffman
    encoding, decompresses it, then returns it.'''
    # Convert from bytes to 8 bit binary strings and join them
    full_binary: str = ''.join(INT_TO_BIN[byte] for byte in data)

    inverse_tree: dict[str, int]
    root: Node; compressed_data: str

    # Check if custom tree bit is flagged
    if int(full_binary[8]):
        root, compressed_data = rebuildHuffmanTree(full_binary)
        inverse_tree = {huffman_code: character for character, huffman_code in findHuffmanCodes(root)[0].items()}
    else:
        # Seperate the padding size and compressed data, ignoring the padding
        padding_size: int = BIN_TO_INT[full_binary[:8]]
        compressed_data: str = full_binary[9:-padding_size] if padding_size else full_binary[9:]
        inverse_tree = INVERSE_STANDARD_TREE

    # Reverse the encoding, then return
    decompressed_data: list[int] = []
    current_code: str = ''
    for bit in compressed_data:
        current_code += bit # add the next bit

        if current_code in inverse_tree:
            decompressed_data.append(inverse_tree[current_code])
            current_code = '' # reset the code

    percentage_saved: float = (len(decompressed_data) - len(data)) / len(decompressed_data) * 100
    if len(decompressed_data) < 40:
        print(f'Comp Msg: {bytes(decompressed_data[:40])}..., Percentage Saved: {percentage_saved:.3f}%')
    return bytes(decompressed_data)



def testing():
    with open('Cryptography/TestFiles/md.txt', 'rb') as file:
        doc = file.read()

    # Compression
    start = perf_counter()
    comp: bytes = compress(doc, True)
    comp_time: float = perf_counter() - start
    comp_rate: float = len(doc) / comp_time
    print(f'Compression: {comp_time:.3f} secs at {comp_rate:,.2f} bytes/second')


    # Decompression
    start = perf_counter()
    decomp: bytes = decompress(comp)
    decomp_time: float = perf_counter() - start
    decomp_rate: float = len(decomp) / decomp_time
    print(f'Decompression: {decomp_time:.3f} secs at {decomp_rate:,.2f} bytes/second')

    outcome: bool = doc == decomp

    assert outcome

    percentage_saved: float = (len(doc) - len(comp)) / len(doc) * 100
    print()
    print(f'Old Length: {len(doc):,} bytes, New Length: {len(comp):,} bytes')
    print(f'Percentage Saved: {percentage_saved:.3f}%')


if __name__ == '__main__':
    from os import system; system('clear')
    from time import perf_counter

    testing()